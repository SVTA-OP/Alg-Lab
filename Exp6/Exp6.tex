% Created 2026-02-17 Tue 08:51
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\author{Saravana Senthilkumar - 3122247001057}
\date{\today}
\title{Session 6: Greedy Algorithms}
\hypersetup{
 pdfauthor={Saravana Senthilkumar - 3122247001057},
 pdftitle={Session 6: Greedy Algorithms},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 30.2 (Org mode 9.7.11)}, 
 pdflang={English}}
\begin{document}

\maketitle
\tableofcontents

\section{1. Union-Find Data Structure}
\label{sec:org4e5c77f}

\subsection{1. Design and Implement UnionFind functions}
\label{sec:org579eb9b}
This block implements Union-Find using standard array access, avoiding list methods.

\begin{verbatim}
def find(parent, i):
    while parent[i] != i:
        parent[i] = parent[parent[i]]
        i = parent[i]
    return i

def union(parent, i, j):
    root_i = find(parent, i)
    root_j = find(parent, j)
    if root_i != root_j:
        parent[root_i] = root_j
        return 1
    return 0

parent = [0, 1, 2, 3, 4]
union(parent, 0, 1)
print(find(parent, 0))
print(find(parent, 1))
\end{verbatim}
\section{2. Priority Queue}
\label{sec:org3d3565c}

\subsection{1. Design and Implement PriorityQ functions}
\label{sec:org6d5d40b}
This block implements a Priority Queue. instead of `sort` or `pop`, it manually iterates to find the smallest weight and uses slicing to remove it.

\begin{verbatim}
def pq_add(pq, w, u, v):
    pq = pq + [[w, u, v]]
    return pq

def pq_remove_min(pq):
    if len(pq) == 0:
        return [], pq

    min_idx = 0
    min_val = pq[0][0]

    i = 1
    while i < len(pq):
        if pq[i][0] < min_val:
            min_val = pq[i][0]
            min_idx = i
        i = i + 1

    item = pq[min_idx]

    # Remove by slicing: elements before + elements after
    pq = pq[:min_idx] + pq[min_idx+1:]

    return item, pq

pq = []
pq = pq_add(pq, 10, 'A', 'B')
pq = pq_add(pq, 5, 'C', 'D')
item, pq = pq_remove_min(pq)
print(item)
\end{verbatim}
\section{3. Kruskal's Algorithm}
\label{sec:orgcabf10c}

\subsection{1. Design KruskalMST(vertices, edges)}
\label{sec:orgdf579ea}
This block implements Kruskal's algorithm using the manual helper functions defined above.

\begin{verbatim}
def KruskalMST(vertices, edges):
    v_map = {}
    idx = 0
    for v in vertices:
        v_map[v] = idx
        idx = idx + 1

    n = len(vertices)
    parent = list(range(n))

    pq = []
    for edge in edges:
        pq = pq_add(pq, edge[2], edge[0], edge[1])

    mst = []
    cost = 0

    while len(pq) > 0:
        item, pq = pq_remove_min(pq)
        w = item[0]
        u = item[1]
        v = item[2]

        u_id = v_map[u]
        v_id = v_map[v]

        if find(parent, u_id) != find(parent, v_id):
            union(parent, u_id, v_id)
            mst = mst + [[u, v, w]]
            cost = cost + w

    return mst, cost

nodes = ['A', 'B', 'C', 'D', 'E', 'F', 'G']
graph_edges = [
    ('E', 'G', 8), ('G', 'F', 5), ('E', 'F', 10),
    ('E', 'B', 18), ('E', 'C', 2), ('F', 'C', 3),
    ('F', 'D', 16), ('B', 'C', 12), ('C', 'D', 30),
    ('B', 'A', 4), ('C', 'A', 14), ('D', 'A', 26)
]

mst, cost = KruskalMST(nodes, graph_edges)
print(cost)
print(mst)
\end{verbatim}
\end{document}
